<?xml version="1.0" encoding="utf-8"?>
<chapter label="708"
         revision="$Id$"
         version="5.0" xml:id="util.features"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Features Specification</title>

  <info>
    <releaseinfo><xref endterm="org.osgi.util.features-version"
    linkend="org.osgi.util.features"/></releaseinfo>
  </info>

  <section>
    <title>Introduction</title>

    <para>
        OSGi has become a platform capable of running large applications for a variety of purposes, 
        including rich client applications, server-side systems and cloud and container based architectures. 
        As these applications are generally based on many bundles, describing each bundle individually 
        in an application definition becomes unwieldy once the number of bundles reaches a certain level. 
    </para>

    <para>
        When developing large scale applications it is often the case that few people know the role of every 
        single bundle or configuration item in the application. To keep the architecture understandable a grouping 
        mechanism is needed that allows for the representation of parts of the application into larger 
        entities that keep reasoning about the system manageable. In such a domain members of teams 
        spread across an organization will need to be able to both develop new parts for the application 
        as well as make tweaks or enhancements to parts developed by others such as adding configuration and 
        resources or changing one or more bundles relevant to their part of the application.
    </para>

    <para>
        The higher level constructs that define the application should be reusable in different contexts, 
        for example if one team has developed a component to handle job processing, different applications 
        should be able to use it, and if needed tune its configuration or other aspects so that it works in 
        each setting without having to know each and every detail that the job processing component is built 
        up from.
    </para>

    <para>
      Applications often carry additional definitions, for example configurations or custom artifacts.
      By supporting custom extensions, features allow these to be encapsuled in a single entity.
    </para>

    <para>
        Systems are often composed by reusing existing building blocks, combining various applications 
        or subsystems together to create a larger system, where all these building blocks work together.
        Architects of these systems need to think about components without having to dive into the 
        individual implementation details of each subcomponent. 
        The features defined in this specification can be used to model such applications. Features
        contain the definition of an application or component and can be composed into larger systems.
    </para>


    <section>
      <title>Essentials</title>

      <itemizedlist>
        <listitem>
          <para><emphasis>Declarative</emphasis> - Features are declarative and can be mapped to different implementations.
          </para>
        </listitem>

        <listitem>
          <para><emphasis>Extensible</emphasis> - Features are extensible with custom content to allow all information related to 
          a feature to be co-located.
          </para>
        </listitem>

        <listitem>
          <para><emphasis>Human Readable</emphasis> - No special software is needed to read or author features.
          </para>
        </listitem>

        <listitem>
          <para><emphasis>Machine Readable</emphasis> - Features can be easily processed by tools.
          </para>
        </listitem>

      </itemizedlist>
    </section>

    <section>
      <title>Entities</title>

      <para>The following entities are used in this specification:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Feature</emphasis> - A feature contains a number of entities that, when provided to a feature launcher can be turned into an executable system. Features can also be building blocks which are assembled into larger systems.</para>
        </listitem>

        <listitem>
          <para><emphasis>Bundles</emphasis> - A feature can contain one ore more bundles.</para>
        </listitem>

        <listitem>
          <para><emphasis>Capabilities</emphasis> and <emphasis>Requirements</emphasis> - A feature can declare additional capabilities and requirements.</para>
        </listitem>

        <listitem>
          <para><emphasis>Configuration</emphasis> - A feature can contain configurations applied to the Configuration Admin specification.</para>
        </listitem>

        <listitem>
          <para><emphasis>Extension</emphasis> - A feature can contain a number of extensions with custom content.</para>
        </listitem>

        <listitem>
          <para><emphasis>Properties</emphasis> - Framework properties can be specified in a feature.</para>
        </listitem>

      </itemizedlist>

        <!--
      <figure pgwide="1">
        <title>Features Entity overview</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" contentdepth="4.100in"
                       contentwidth="6.000in" fileref="features-overview.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
        -->
    </section>
  </section>

  <section>
    <title>Feature</title>

    <para>
      Features are defined by declaring feature models in JSON documents or by using the Feature API.
      Each Feature has a unique ID which includes a version. It can hold a number of entities, including a list of bundles, configurations, capabilities, requirements and others. Features are extensible, so a Feature can also hold any number of custom entities which are related to the Feature.
    </para>

    <para>
Features may have dependencies on other Features. Features inherit the capabilities and requirements from all bundles listed in the Feature, and can also have additional capabilities and requirements on the Feature level. 
    </para>

    <para>
      Once created, a Feature is immutable. Its definition cannot be modified. However another Feature with a different identity can be created which is based on a given Feature using the prototype mechanism. 
    </para>

    <para>
      Additionally it’s possible to record caching related information in a Feature through transient extensions, however this cached content is not significant for the definition of the Feature.
    </para>

    <section xml:id="util.feature-identifiers">
      <title>Identifiers</title>

      <para>
        Identifiers used throughout this specification are defined using the Maven Identifier model. They are composed of the following parts:

        <itemizedlist>
          <listitem><para>Group ID</para></listitem>
          <listitem><para>Artifact ID</para></listitem>
          <listitem><para>Version</para></listitem>
          <listitem><para>Type (optional)</para></listitem>
          <listitem><para>Classifier (optional)</para></listitem>
        </itemizedlist>
        For more information see https://maven.apache.org/pom.html.
        The format used to specify identifiers is as follows:
        <programlisting>group-id ':' artifact-id [ ':' type [ ':' classifier ] ] ':' version</programlisting>
      </para>
    </section>

    <section>
      <title>Feature Identifier</title>
      <para>
        Each Feature has a unique identifier. Apart from providing a persistent handle to the Feature it also provides enough information to find the Feature in an artifact repository. This identifier is defined using the format described in 
        <xref linkend="util.feature-identifiers"/>.
As Features are immutable, a given Feature ID always refers to the same Feature.
      </para>
    </section>
  </section>

  <section>
    <title>Bundles</title>
    <para>
      Features often list a number of bundles that provide the functionality provided by the Feature. Bundles are listed by referencing them so that they can be resolved from a repository. Bundles can have metadata associated with them, such as the relative start order of the bundle in the Feature. Custom metadata can also be provided. A single Feature can provide multiple versions of the same bundle, if desired.
    </para>
    <para>
      Bundles are referenced using the identifier format described in 
      <xref linkend="util.feature-identifiers"/>.
      This means that Bundles are referenced using their Maven coordinates.
    </para>
  </section>

  <section>
    <title>Capabilities &amp; Requirements</title>
    <para>
      Features inherit all capabilities an requirements from their bundles. Additional capabilities and requirements can be added to the feature directly.
    </para>
  </section>

  <section>
    <title>Configurations</title>
    <para>
      Features support configuration using the OSGi Configurator syntax.
    </para>

    <para>
      It is an error to define the same PID (or Factory PID) twice in a single feature model.
    </para>
  </section>

  <section>
    <title>Framework properties</title>
    <para>
      When a Feature is launched in an OSGi framework it may be necessary to specify Framework properties. These can be provided in the Framework Properties section of the Feature Model.
      If a Feature Management Agent is not able to set the Framework properties it may fail.
    </para>
  </section>

  <section>
    <title>Variables</title>
    <para>
      Configurations and Framework Properties support late binding of values. This enables setting these items through a Management Agent, for example to specify a database user name or other information that may be variable between runtimes.
    </para>
  </section>

  <section>
    <title>Prototype</title>
    <para>
      If a Feature is similar to another Feature, it can use the other Feature as its prototype. Entities can be removed from the prototype and additional entities can be added in the resulting Feature. Prototypes can be used to create variants of existing Features. The newly created Features must have a different ID than the prototype they’re based on. 
    </para>
  </section>
    
  
  <section>
    <title>Security</title>

    <para>
    ...</para>
  </section>

  <!--
  <xi:include href="../../generated/javadoc/docbook/org.osgi.util.features.xml"/>
  -->

  <section>
    <title>References</title>

    <bibliolist>
      <bibliomixed xml:id="util.features-jls.ref"><title>The Java Language
      Specification, Java SE 8 Edition</title><biblioid class="uri"><link
      xlink:href="https://docs.oracle.com/javase/specs/jls/se8/html/index.html"/></biblioid></bibliomixed>
    </bibliolist>
  </section>
</chapter>
